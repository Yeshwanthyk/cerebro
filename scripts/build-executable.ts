#!/usr/bin/env bun
/**
 * Build script for creating a single executable Cerebro binary
 * - Builds the React frontend with Bun (web/dist)
 * - Embeds static assets into globalThis.__EMBEDDED_ASSETS__
 * - Compiles the real CLI/server (src/index.ts) with Bun --compile
 *   so the single binary uses the same SQLite state & APIs as dev.
 */

import { existsSync } from "fs";
import { mkdir, rm, writeFile, readdir, readFile, stat } from "fs/promises";
import path from "path";
import { $ } from "bun";

console.log("\nüöÄ Building Cerebro as a single executable...\n");

const rootDir = path.resolve(import.meta.dir, "..");
const webDir = path.join(rootDir, "web");
const distDir = path.join(webDir, "dist");
const buildDir = path.join(rootDir, "dist-exe");

// Clean previous build
if (existsSync(buildDir)) {
  console.log(`üóëÔ∏è  Cleaning previous executable build at ${buildDir}`);
  await rm(buildDir, { recursive: true, force: true });
}
await mkdir(buildDir, { recursive: true });

// Build the React frontend with Bun
console.log("üì¶ Building React frontend with Bun...");
await $`cd ${webDir} && bun run build`;

// Recursively read all files from a directory
async function getAllFiles(dir: string, baseDir = ""): Promise<Array<{ path: string; content: string }>> {
  const files: Array<{ path: string; content: string }> = [];
  const entries = await readdir(dir);

  for (const entry of entries) {
    const fullPath = path.join(dir, entry);
    const fileStat = await stat(fullPath);

    if (fileStat.isDirectory()) {
      const subFiles = await getAllFiles(fullPath, path.join(baseDir, entry));
      files.push(...subFiles);
    } else {
      const relativePath = path.join(baseDir, entry).replace(/\\/g, "/");
      const content = await readFile(fullPath);
      files.push({ path: relativePath, content: content.toString("base64") });
    }
  }

  return files;
}

// Read all static files
console.log("üìÇ Reading static files from dist...");
const staticFiles = await getAllFiles(distDir);
console.log(`   Found ${staticFiles.length} files to embed`);

// Generate embedded files code
const embeddedFilesCode = staticFiles
  .map((file) => `assets.set("${file.path}", { content: "${file.content}", mimeType: getMimeType("${file.path}") });`)
  .join("\n");

// Wrapper that injects assets and runs the real CLI/server
const serverCode = `#!/usr/bin/env bun
// Auto-generated by scripts/build-executable.ts
// Embeds frontend assets and runs src/index.ts (CLI + server)

function getMimeType(file: string): string {
  const ext = file.split(".").pop()?.toLowerCase();
  const types: Record<string, string> = {
    html: "text/html", js: "application/javascript", css: "text/css",
    json: "application/json", png: "image/png", jpg: "image/jpeg",
    svg: "image/svg+xml", ico: "image/x-icon", woff: "font/woff",
    woff2: "font/woff2", ttf: "font/ttf", otf: "font/otf", map: "application/json",
  };
  return types[ext || ""] || "application/octet-stream";
}

const assets = new Map<string, { content: string; mimeType: string }>();
${embeddedFilesCode}

(globalThis as any).__EMBEDDED_ASSETS__ = assets;

// Delegate to the real entrypoint (includes CLI + server using SQLite)
import "../src/index.ts";
`;

// Write wrapper server file
const serverPath = path.join(buildDir, "server.ts");
await writeFile(serverPath, serverCode);
console.log("üìù Generated embedded server wrapper");

// Compile to executable
console.log("\nüî® Compiling to single executable with Bun...");
const exePath = path.join(buildDir, "cerebro");

try {
  await $`bun build ${serverPath} --compile --minify --outfile ${exePath}`;

  const stats = await stat(exePath);
  const sizeMB = (stats.size / 1024 / 1024).toFixed(2);

  console.log("\n‚úÖ Build successful!");
  console.log(`üì¶ Executable: ${exePath}`);
  console.log(`üìè Size: ${sizeMB} MB`);
  console.log("\nüöÄ Usage:");
  console.log(`   ${exePath} start`);
  console.log(`   ${exePath} start /path/to/repo -p 3030 -o`);
  console.log(`   ${exePath} repo list`);
} catch (error) {
  console.error("‚ùå Build failed:", error);
  process.exit(1);
}
